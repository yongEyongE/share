# 4.5 시간 복잡도
## O 표기법의 의미
* O 표기법은 대략적으로 함수의 상한을 나타낸다는데 그 의미가 있음
* N에 대한 함수 f(N)이 주어질 때, f(N)=O(g(N))이라고 쓰는 것은 다음과 같은 의미
    >아주 큰 N<sub>0</sub> 와 C(N(<sub>0</sub>,C>0)를 적절히 선택하면 N<sub>0</sub>≤N인 모든 N에 대해 |f(N)|≤C*|g(N)|이 참이 되도록 할 수 있다

  * 예)

    * N<sup>2</sup> + 100 * N + 1 = O(N<sup>2</sup>)

    * N이 엄청나게 커지면 N<sup>2</sup>과 N<sup>2</sup> + 100 * N + 1 사이에는 큰 차이가 없어짐

    * 이때 적절한 상수 C를 선택해서 N<sup>2</sup>에 곱해주면 항상 N<sup>2</sup>이 더 크다고 할 수 있음

    * N<sub>0</sub>=1000, C=2라고 하면 C*N<sup>2</sup>=2백만 이므로 N<sup>2</sup> + 100 * N +1 보다 훨씬 큼
  
* O 표기법이 수행 시간의 상한을 나타낸다 ≠ 알고리즘의 최악의 수행 시간을 알아냈다

* O 표기법은 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 최의 수행 시간과 관련은 없음

  * 예)
    * 퀵 정렬의 최악 수행 시간의 최고차항 = N<sup>2</sup> --> 최악의 시간 복잡도 = O(N<sup>2</sup>)
    * 퀵 정렬의 평균 수행 시간의 최고차항 = NlogN --> 평균 시간 복잡도 = O(NlogN)

***

## 시간 복잡도 분석 연습
* 두 가지 예제를 통해 시간 복잡도 분석을 연습

* 선택 정렬 (selection sort)
  * 모든 i에 대해 A[i..N-1]에서 가장 작은 원소를 찾은 뒤, 이것을 A[i]에 넣은 것을 반복
    <pre><code>
    void selectionSort(vector<int>& A) {
      for(int i = 0; i < A.size(); ++i) {
        int minIndex = i;
        for(int j = i+1; j < A.size(); ++j)
          if(A[minIndex] > A[j])
            minIndex = j;
        swap(A[i], A[minIndex]);
      }
    }
    </code></pre>
  * 시간 복잡도
    * if문 수행횟수  
      i=0 --> N-1번  
      i=1 --> N-2번  
      ...     ...  
      i=N-1 --> 0번  
      --> 등차수열의 합 공식 활용하면 O(N<sup>2</sup>)
    * 간단하게 최대 O(N)번 실행되는 for문이 두 개 겹쳐 있으므로 O(N<sup>2</sup>)이라고 계산해도 됨  
    * A[]의 원소들과는 상관 없이 A[]의 크기에 의해서만 결정 --> 최악의 경우와 최선의 경우의 시간 복잡도가 같음  
    
* 삽입 정렬  
  * 전체 배열 중 정렬되어 있는 부분 배열에 새 원소를 끼워넣는 일을 반복
    <pre><code>
    void insertionSort(vector<int>& A) {
      for(int i = 0; i < A.size(); ++i) {
        int j = i;
        while(j > 0 && A[j-1] > A[j]) {
          swap(A[j-1], A[j]);
          --j;
        }
      }
    }
    </code></pre>
    * 현재 값보다 작은 숫자를 만날 때까지 현재 값을 앞으로 이동시킴  
  * 시간 복잡도  
    * while문의 수행 횟수는 처음에 A[i]에 위치한 값에 따라 달라짐  
    * 입력 배열의 초기 순서에 따라 비교의 횟수가 달라짐
    * 최선의 경우
      * 처음부터 이미 정렬된 배열이 주어지는 경우  
      * while문의 시간 복잡도 : O(1) --> 전체 시간 복잡도 : O(N)  
    * 최악의 경우
      * 역순으로 정렬된 배열이 주어지는 경우  
      * while문의 시간 복잡도 : O(N) --> 전체 시간 복잡도 : O(N<sup>2</sup>)  
* 대부분의 경우 삽입 정렬이 선택 정렬보다 빠름  
* 실제로 삽입 정렬은 흔히 사용하는 O(N<sup>2</sup>) 정렬 중 가장 빠른 알고리즘으로 알려져 있음  
***  

## 시간 복잡도의 분할 상환
* 시간 복잡도를 항상 반복문의 개수를 세는 것으로만 결정하지는 않음  
* 더 정확한 계산 방법 중 하나인 시간 복잡도의 분할 상환 분석 (amortized analysis)  
* 정확한 소개는 이 책의 범위를 벗어나므로 개념만...  
* N개의 작업을 순서대로 하는데, 각 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 평균 시간이 일정한 경우  
* 각 작업에 걸리는 평균 시간 = 전체 시간 / 작업의 개수  
* 분할 상환 분석을 이용하면 시간이 오래 걸려 실행하지 못할 것이라고 여겼던 작업이 시간 안에 돌아가는 것을 이해할 수 있음  
